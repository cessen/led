//! Single byte encodings that extend ascii.  Their code is auto-generated
//! by build.rs

use core;
use {DecodeError, DecodeResult, EncodeError, EncodeResult};

pub mod ibm866 {
    // Generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/ibm866.rs"));
}

pub mod iso_8859_2 {
    // Generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/iso-8859-2.rs"));
}

// pub mod iso_8859_3 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-3.rs"));
// }

// pub mod iso_8859_4 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-4.rs"));
// }

// pub mod iso_8859_5 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-5.rs"));
// }

// pub mod iso_8859_6 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-6.rs"));
// }

pub mod iso_8859_7 {
    // Generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/iso-8859-7.rs"));
}

// pub mod iso_8859_8 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-8.rs"));
// }

// pub mod iso_8859_10 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-10.rs"));
// }

// pub mod iso_8859_13 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-13.rs"));
// }

// pub mod iso_8859_14 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-14.rs"));
// }

// pub mod iso_8859_15 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-15.rs"));
// }

// pub mod iso_8859_16 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-16.rs"));
// }

// pub mod koi8_r {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/koi8-r.rs"));
// }

// pub mod koi8_u {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/koi8-u.rs"));
// }

// pub mod macintosh {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/macintosh.rs"));
// }

// pub mod windows874 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-874.rs"));
// }

// pub mod windows1250 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1250.rs"));
// }

// pub mod windows1251 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1251.rs"));
// }

pub mod windows1252 {
    // Generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/windows-1252.rs"));
}

// pub mod windows1253 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1253.rs"));
// }

// pub mod windows1254 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1254.rs"));
// }

// pub mod windows1255 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1255.rs"));
// }

// pub mod windows1256 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1256.rs"));
// }

// pub mod windows1257 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1257.rs"));
// }

// pub mod windows1258 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1258.rs"));
// }

// pub mod x_mac_cyrillic {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/x-mac-cyrillic.rs"));
// }

/// This is shared among the single byte encoders, and is shallowly
/// wrapped in each of their modules.
#[inline]
fn single_byte_encode_from_str<'a>(
    table: &[(char, u8)],
    input: &str,
    output: &'a mut [u8],
) -> EncodeResult<'a> {
    // Do the encode.
    let mut input_i = 0;
    let mut output_i = 0;
    for (offset, c) in input.char_indices() {
        if output_i >= output.len() {
            break;
        }
        if c as u32 <= 127 {
            output[output_i] = c as u8;
            output_i += 1;
            input_i = offset + 1;
        } else {
            if let Ok(i) = table.binary_search_by_key(&c, |x| x.0) {
                output[output_i] = table[i].1;
                output_i += 1;
                input_i = offset + 1;
            } else {
                return Err(EncodeError {
                    character: c,
                    error_range: (offset, offset + c.len_utf8()),
                    output_bytes_written: output_i,
                });
            }
        }
    }

    // Calculate how much of the input was consumed.
    if input_i > input.len() {
        input_i = input.len();
    } else {
        while !input.is_char_boundary(input_i) {
            input_i += 1;
        }
    }

    Ok((input_i, &output[..output_i]))
}

/// This is shared among the single byte decoders, and is shallowly
/// wrapped in each of their modules.
#[inline]
fn single_byte_decode_to_str<'a>(
    table: &[char; 128],
    input: &[u8],
    output: &'a mut [u8],
) -> DecodeResult<'a> {
    let mut input_i = 0;
    let mut output_i = 0;
    for &byte in input.iter() {
        if byte < 0x80 {
            // 1-byte case
            if output_i >= output.len() {
                break;
            }
            output[output_i] = byte;
            input_i += 1;
            output_i += 1;
        } else {
            // Use lookup table.
            let code = table[byte as usize - 0x80];
            if code == '�' {
                // Error: undefined byte.
                return Err(DecodeError {
                    error_range: (input_i, input_i + 1),
                    output_bytes_written: output_i,
                });
            }
            // Encode to utf8
            let mut buf = [0u8; 4];
            let s = code.encode_utf8(&mut buf);
            if (output_i + s.len()) > output.len() {
                break;
            }
            output[output_i..(output_i + s.len())].copy_from_slice(s.as_bytes());
            input_i += 1;
            output_i += s.len();
        }
    }

    Ok((input_i, unsafe {
        core::str::from_utf8_unchecked(&output[..output_i])
    }))
}

//===========================================================================

// Testing is done with iso-8859-7, since it has a few undefined characters,
// allowing us to test handling of those.
#[cfg(test)]
mod tests {
    use super::iso_8859_7::*;
    use {DecodeError, EncodeError};

    #[test]
    fn encode_01() {
        let text = "Hello world!";
        let mut buf = [0u8; 0];
        let (consumed_count, encoded) = encode_from_str(text, &mut buf).unwrap();
        assert_eq!(consumed_count, 0);
        assert_eq!(encoded, &[]);
    }

    #[test]
    fn encode_02() {
        let text = "Hello world!";
        let mut buf = [0u8; 1];
        let (consumed_count, encoded) = encode_from_str(text, &mut buf).unwrap();
        assert_eq!(consumed_count, 1);
        assert_eq!(encoded, "H".as_bytes());
    }

    #[test]
    fn encode_03() {
        let text = "Hello world!";
        let mut buf = [0u8; 2];
        let (consumed_count, encoded) = encode_from_str(text, &mut buf).unwrap();
        assert_eq!(consumed_count, 2);
        assert_eq!(encoded, "He".as_bytes());
    }

    #[test]
    fn encode_04() {
        let text = "Hello world!";
        let mut buf = [0u8; 64];
        let (consumed_count, encoded) = encode_from_str(text, &mut buf).unwrap();
        assert_eq!(consumed_count, 12);
        assert_eq!(encoded, "Hello world!".as_bytes());
    }

    #[test]
    fn encode_05() {
        let text = "Hello world!こ";
        let mut buf = [0u8; 12];
        let (consumed_count, encoded) = encode_from_str(text, &mut buf).unwrap();
        assert_eq!(consumed_count, 12);
        assert_eq!(encoded, "Hello world!".as_bytes());
    }

    #[test]
    fn decode_01() {
        let data = [
            0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21,
        ]; // "Hello world!"
        let mut buf = [0u8; 0];
        let (consumed_count, decoded) = decode_to_str(&data, &mut buf).unwrap();
        assert_eq!(consumed_count, 0);
        assert_eq!(decoded, "");
    }

    #[test]
    fn decode_02() {
        let data = [
            0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21,
        ]; // "Hello world!"
        let mut buf = [0u8; 1];
        let (consumed_count, decoded) = decode_to_str(&data, &mut buf).unwrap();
        assert_eq!(consumed_count, 1);
        assert_eq!(decoded, "H");
    }

    #[test]
    fn decode_03() {
        let data = [
            0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21,
        ]; // "Hello world!"
        let mut buf = [0u8; 2];
        let (consumed_count, decoded) = decode_to_str(&data, &mut buf).unwrap();
        assert_eq!(consumed_count, 2);
        assert_eq!(decoded, "He");
    }

    #[test]
    fn decode_04() {
        let data = [
            0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21,
        ]; // "Hello world!"
        let mut buf = [0u8; 64];
        let (consumed_count, decoded) = decode_to_str(&data, &mut buf).unwrap();
        assert_eq!(consumed_count, 12);
        assert_eq!(decoded, "Hello world!");
    }

    #[test]
    fn decode_05() {
        let data = [
            0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE,
            0xCF, 0xD0, 0xD1, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,
        ]; // "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ"
        let mut buf = [0u8; 128];
        let (consumed_count, decoded) = decode_to_str(&data, &mut buf).unwrap();
        assert_eq!(consumed_count, 24);
        assert_eq!(decoded, "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ");
    }

    #[test]
    fn encode_error_01() {
        let text = "こello world!";
        let mut buf = [0u8; 64];
        assert_eq!(
            encode_from_str(text, &mut buf),
            Err(EncodeError {
                character: 'こ',
                error_range: (0, 3),
                output_bytes_written: 0,
            })
        );
    }

    #[test]
    fn encode_error_02() {
        let text = "\u{00C0}ello world!";
        let mut buf = [0u8; 64];
        assert_eq!(
            encode_from_str(text, &mut buf),
            Err(EncodeError {
                character: '\u{00C0}',
                error_range: (0, 2),
                output_bytes_written: 0,
            })
        );
    }

    #[test]
    fn encode_error_03() {
        let text = "Hこllo world!";
        let mut buf = [0u8; 64];
        assert_eq!(
            encode_from_str(text, &mut buf),
            Err(EncodeError {
                character: 'こ',
                error_range: (1, 4),
                output_bytes_written: 1,
            })
        );
    }

    #[test]
    fn encode_error_04() {
        let text = "H\u{00C0}llo world!";
        let mut buf = [0u8; 64];
        assert_eq!(
            encode_from_str(text, &mut buf),
            Err(EncodeError {
                character: '\u{00C0}',
                error_range: (1, 3),
                output_bytes_written: 1,
            })
        );
    }

    #[test]
    fn encode_error_05() {
        let text = "Heこlo world!";
        let mut buf = [0u8; 3];
        assert_eq!(
            encode_from_str(text, &mut buf),
            Err(EncodeError {
                character: 'こ',
                error_range: (2, 5),
                output_bytes_written: 2,
            })
        );
    }

    #[test]
    fn encode_error_06() {
        let text = "He\u{00C0}lo world!";
        let mut buf = [0u8; 3];
        assert_eq!(
            encode_from_str(text, &mut buf),
            Err(EncodeError {
                character: '\u{00C0}',
                error_range: (2, 4),
                output_bytes_written: 2,
            })
        );
    }

    #[test]
    fn decode_error_01() {
        let data = [
            0x48, 0xAE, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21,
        ]; // "Hello world!" with an error on the second byte (undefined byte).
        let mut buf = [0u8; 64];
        let error = decode_to_str(&data, &mut buf);
        assert_eq!(
            error,
            Err(DecodeError {
                error_range: (1, 2),
                output_bytes_written: 1,
            })
        );
    }

    #[test]
    fn decode_error_02() {
        let data = [
            0x48, 0xD2, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21,
        ]; // "Hello world!" with an error on the second byte (undefined byte).
        let mut buf = [0u8; 64];
        let error = decode_to_str(&data, &mut buf);
        assert_eq!(
            error,
            Err(DecodeError {
                error_range: (1, 2),
                output_bytes_written: 1,
            })
        );
    }

    #[test]
    fn decode_error_03() {
        let data = [
            0x48, 0xFF, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x21,
        ]; // "Hello world!" with an error on the second byte (undefined byte).
        let mut buf = [0u8; 64];
        let error = decode_to_str(&data, &mut buf);
        assert_eq!(
            error,
            Err(DecodeError {
                error_range: (1, 2),
                output_bytes_written: 1,
            })
        );
    }
}
