//! Single byte encodings that extend ascii.  Their code is auto-generated
//! by build.rs

use core;
use {DecodeError, DecodeResult, EncodeError, EncodeResult};

pub mod ibm866 {
    // Generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/ibm866.rs"));
}

pub mod iso_8859_2 {
    // Generated by build.rs
    include!(concat!(env!("OUT_DIR"), "/iso-8859-2.rs"));
}

// pub mod iso_8859_3 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-3.rs"));
// }

// pub mod iso_8859_4 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-4.rs"));
// }

// pub mod iso_8859_5 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-5.rs"));
// }

// pub mod iso_8859_6 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-6.rs"));
// }

// pub mod iso_8859_7 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-7.rs"));
// }

// pub mod iso_8859_8 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-8.rs"));
// }

// pub mod iso_8859_10 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-10.rs"));
// }

// pub mod iso_8859_13 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-13.rs"));
// }

// pub mod iso_8859_14 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-14.rs"));
// }

// pub mod iso_8859_15 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-15.rs"));
// }

// pub mod iso_8859_16 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/iso-8859-16.rs"));
// }

// pub mod koi8_r {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/koi8-r.rs"));
// }

// pub mod koi8_u {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/koi8-u.rs"));
// }

// pub mod macintosh {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/macintosh.rs"));
// }

// pub mod windows874 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-874.rs"));
// }

// pub mod windows1250 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1250.rs"));
// }

// pub mod windows1251 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1251.rs"));
// }

// pub mod windows1252 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1252.rs"));
// }

// pub mod windows1253 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1253.rs"));
// }

// pub mod windows1254 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1254.rs"));
// }

// pub mod windows1255 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1255.rs"));
// }

// pub mod windows1256 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1256.rs"));
// }

// pub mod windows1257 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1257.rs"));
// }

// pub mod windows1258 {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/windows-1258.rs"));
// }

// pub mod x_mac_cyrillic {
//     // Generated by build.rs
//     include!(concat!(env!("OUT_DIR"), "/x-mac-cyrillic.rs"));
// }

/// This is shared among the single byte encoders, and is shallowly
/// wrapped in each of their modules.
#[inline]
fn single_byte_encode_from_str<'a>(
    table: &[(char, u8)],
    input: &str,
    output: &'a mut [u8],
) -> EncodeResult<'a> {
    // Do the encode.
    let mut input_i = 0;
    let mut output_i = 0;
    for (offset, c) in input.char_indices() {
        if output_i >= output.len() {
            break;
        }
        if let Ok(i) = table.binary_search_by_key(&c, |x| x.0) {
            output[output_i] = table[i].1;
            output_i += 1;
            input_i = offset + 1;
        } else {
            return Err(EncodeError {
                character: c,
                error_range: (offset, offset + c.len_utf8()),
                output_bytes_written: output_i,
            });
        }
    }

    // Calculate how much of the input was consumed.
    if input_i > input.len() {
        input_i = input.len();
    } else {
        while !input.is_char_boundary(input_i) {
            input_i += 1;
        }
    }

    Ok((input_i, &output[..output_i]))
}

/// This is shared among the single byte decoders, and is shallowly
/// wrapped in each of their modules.
#[inline]
fn single_byte_decode_to_str<'a>(
    table: &[char; 128],
    input: &[u8],
    output: &'a mut [u8],
) -> DecodeResult<'a> {
    let mut input_i = 0;
    let mut output_i = 0;
    for &byte in input.iter() {
        if byte < 0x80 {
            // 1-byte case
            if output_i >= output.len() {
                break;
            }
            output[output_i] = byte;
            input_i += 1;
            output_i += 1;
        } else {
            // Use lookup table.
            let code = table[byte as usize - 0x80];
            if code == 'ï¿½' {
                // Error: undefined byte.
                return Err(DecodeError {
                    error_range: (input_i, input_i + 1),
                    output_bytes_written: output_i,
                });
            }
            // Encode to utf8
            let mut buf = [0u8; 4];
            let s = code.encode_utf8(&mut buf);
            if (output_i + s.len()) > output.len() {
                break;
            }
            output[output_i..(output_i + s.len())].copy_from_slice(s.as_bytes());
            input_i += 1;
            output_i += s.len();
        }
    }

    Ok((input_i, unsafe {
        core::str::from_utf8_unchecked(&output[..output_i])
    }))
}
